## 为什么要做这个项目

### 背景痛点

市面上常见的 IM 机器人（QQ / 微信 / TG / Discord 等）实现形式大多是「单体 + 针对性适配」：

* 逻辑处理代码紧耦合具体机器人实现，同一套处理逻辑（例如问答、加群审批功能）需要在不同机器人中重复实现。
* 多账号 / 多平台并存时，逻辑分散、配置重复，例如一个QQ机器人想分别用在不同场景，需要把所有逻辑写到一起，如果要升级或者增加新的功能，需要在原来代码上修改且需要重启机器人。
* 功能累计以后，单体内聚合：部署风险放大、回滚困难、性能扩容只能整体横向复制、资源浪费。
* 想引入 AI Agent / 工具调用（搜索、数据库、知识库、跨系统操作）时缺少清晰的“工具编排”层，只能在业务代码里不断堆 if / switch。
* 缺乏面向云原生（弹性、观测、滚动升级、隔离）的分层抽象。

### 设计目标

围绕“协议多态 + 能力编排 + 可扩展演进”三件事：

1. 协议接入解耦：将不同 onebot 实现（lagrange.onebot、go-cqhttp、……）统一抽象为事件与发送指令，不在业务层出现任何具体 SDK 逻辑。
2. 规则化路由：把“消息该交给谁处理”从代码里抽离成可配置的规则（未来可升级为 DSL / 策略引擎 / 动态热更新）。
3. 处理逻辑微服务化 / Agent 化：每个 Agent 聚焦一个“能力域”（问答、管控、知识检索、情感陪伴、任务执行等），支持独立生命周期、独立扩缩容与灰度。
4. 工具与模型可插拔：通过 MCP（Model Context Protocol）模式，把外部工具（搜索、发送、知识、存储、调用下游系统）视作统一的“函数接口”，便于组合与安全治理。
5. 云原生友好：天然适配 Docker / K8s，便于利用 HPA、ServiceMesh、日志 / 指标 / Trace、滚动升级、故障隔离。
6. 多账号 / 多平台统一上下文：同一个“用户 / 群体”可跨协议映射同一个语义身份，方便做长程记忆与行为画像。
7. 可观测与治理：清晰的边界（入口适配 / 分发 / Agent / 工具调用 / 回发），为限流、熔断、审计、追踪打好基础。

### 与传统机器人架构的差异
| 维度 | 传统单体机器人 | 本项目框架 |
|------|----------------|-------------|
| 协议适配 | 直接嵌入业务 | 通过 Adapter 标准化事件 |
| 功能扩展 | 追加代码堆积 | 新增独立 Agent / MCP Server |
| 多平台多账号 | 各自一套逻辑 | 统一分发 + 规则化路由 |
| 发送逻辑 | 内部硬编码 | 专用发送 MCP，清晰出口控制 |
| 伸缩 | 整体放大 | 热点 Agent 单独扩容 |
| 稳定性 | 功能相互影响 | 进程/容器隔离，故障域更小 |
| 引入 AI / 工具 | 直接耦合 | MCP 抽象，统一调用模式 |
| 运维观测 | 日志杂糅 | 明确链路阶段可追踪 |

### 适用场景
* 需要统一管理多个 QQ / 微信 / 其它 onebot 兼容平台账号的团队或个人。
* 希望用统一 Agent 能力对接多个社区（QQ群 + 微信群）并共享知识与上下文。
* 想持续演进：从简单问答 → 多工具编排 → 任务执行 / 自动化运营。
* 需要拆分团队协作：有人写协议接入 / 有人写 Agent / 有人写工具 / 有人写规则。
* 需要对不同功能做独立弹性（例如问答 Agent 很忙，管理 Agent 很闲）。

### 不适用与当前限制
* 只是写一个单账号、单功能“提醒/复读”小机器人：本框架引入的分层反而会使得系统变得过于复杂。
* 对极致低延迟（毫秒级）无强需求但要极简部署的场景，可用更简单单体。
* 目前规则路由仍是基础形态，需要手动配置yaml文件。
* 跨平台用户身份合并与长程记忆仍在规划中（暂需 Agent 自己处理或轻量存储）。
* 缺少完善的可观测基建（Tracing / 指标 / 熔断限流）——属于后续 Roadmap。

### 一个易懂的“为什么”总结

本项目做的不是“又一个机器人”，而是：把“消息入口”“决策能力”“工具调用”“协议发送”四件事切干净，再用云原生方式把弹性、可演进能力提前内建。这样你可以**更快拼装复杂行为**、**更安全地演化**、**更低风险地扩展到多平台多账号**。

> 如果你只想快速写一个功能少的单账号机器人：选别的轻量方案即可；
> 如果你想打造一个可持续演进、能像“团队助手 / 运营中枢 / 智能多工具代理”的体系，这里适合你。

下面是更低层的系统架构与交互说明。
